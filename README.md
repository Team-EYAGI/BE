<p align="center">
<img src="https://user-images.githubusercontent.com/61370487/171013112-796a9d06-6b91-4012-9af7-ee9ccfb20eaf.png" alt="pick-git-logo" width="300" height="300">
</p>
<div align="center">
  
💻 다양한 사람들의 목소리를 연결하는 오디오북 사이트</br>
🌏 [이야기 (eyagi)](https://www.eyagibook.shop/)

</div>
<div align="center">
  
<a href="https://balanced-desk-3a4.notion.site/EYAGI-06e6113484324fe8ba37ec83e5e70b8d"><img src="https://img.shields.io/badge/Notion-%23000000.svg?style=for-the-badge&logo=notion&logoColor=white&link=https://balanced-desk-3a4.notion.site/EYAGI-06e6113484324fe8ba37ec83e5e70b8d/"/></a>
<a href="https://www.instagram.com/_eyagi_"><img src="https://img.shields.io/badge/Instagram-%23E4405F.svg?style=for-the-badge&logo=Instagram&logoColor=white&link=https://www.instagram.com/_eyagi_/"/></a>

  
</div>
<br/>

## 🙌 프로젝트 소개
 저희 EYAGI(이야기)에서는
책을 "듣고 싶은 사람"이 원하는 취향의 목소리와 낭독 스타일을 찾아 책을 들으며 낭독자에게 반응을 주고, 듣고싶은 책이 있다면 오디오북으로 요청글을 올릴 수도 있습니다.

자신의 목소리를 "들려주고 싶은 사람"은 오디오북으로 등록하고 싶은 책을 찾아, 펀딩을 신청하면 자신에게 달리는 사람들의 호감도를 확인 할 수 있고, 그로 인해 얼마나 많은 사람들이 내 오디오를 들어줄지 확인 한 후, 오디오북 "연재"를 시작할 수 있습니다. (펀딩 신청시, 목표치를 정하고 달성이 되면 연재를 시작합니다! )
이렇게 "듣고 싶은 사람"과 "들려주고 싶은 사람이" 함께 상부상조하는 오디오북 서비스입니다.

여러 사람들이 올려놓은 재밌는 오디오북도 들어보고!
크리에이터(낭독자)로 전환 신청하여 자신의 목소리를 세상 밖에 들려주세요!

## :books: eyagi(이야기)
|메인 페이지|오디오북 페이지|댓글|
|:-:|:-:|:-:|
|<img src=https://user-images.githubusercontent.com/61370487/171026913-adb69bee-9171-4b12-b273-8f1a5fe828f3.gif>|<img src=https://user-images.githubusercontent.com/61370487/171030696-98bbaa9e-347b-4633-956c-77462db17670.gif>|<img src=https://user-images.githubusercontent.com/61370487/171026534-71d090f4-0d17-465b-aa59-c2384232e88c.gif>|
|<b>팔로우</b>|<b>오디오북요청</b>|<b>채팅</b>|
|<img src=https://user-images.githubusercontent.com/61370487/171026610-b4584b86-0174-4c28-ae57-b25fe1f561f8.gif>|<img src=https://user-images.githubusercontent.com/61370487/171030045-42a40812-b807-4b52-ab75-199d88a075eb.gif>|<img src=https://user-images.githubusercontent.com/61370487/171029947-8c62bbd1-fe94-41f6-9714-0a08e9e63151.gif>|
|<b>펀딩</b>|<b>검색</b>|<b>마이페이지</b>|
|<img src=https://user-images.githubusercontent.com/61370487/171026925-7215b3f8-7369-4f58-a4f6-bd57493b21ed.gif>|<img src=https://user-images.githubusercontent.com/61370487/171030108-3e4bc940-20ff-497a-9484-e920b958cef9.gif>|<img src=https://user-images.githubusercontent.com/61370487/171030132-8b300843-90f0-4e72-8271-933c75026aff.gif>|

## 👨‍💻👩‍💻 팀원 소개
#### `Backend`
<a href="https://github.com/EunheaSong" target="_blank"><img height="40"  src="https://img.shields.io/static/v1?label=Spring&message=송은혜 &color=08CE5D&style=for-the-badge&>"/></a>
<a href="https://github.com/akrwkdrrr99" target="_blank"><img height="40"  src="https://img.shields.io/static/v1?label=Spring&message=김승균 &color=08CE5D&style=for-the-badge&>"/></a>
<a href="https://github.com/yunju2" target="_blank"><img height="40"  src="https://img.shields.io/static/v1?label=Spring&message=권윤주 &color=08CE5D&style=for-the-badge&>"/></a>


<br>

#### `Frontend`
<a href="https://github.com/JIEUN24" target="_blank"><img height="40"  src="https://img.shields.io/static/v1?label=React&message=최지은 &color=61dafb&style=for-the-badge&>"/></a>
<a href="https://github.com/hyopp" target="_blank"><img height="40"  src="https://img.shields.io/static/v1?label=React&message=권효빈 &color=61dafb&style=for-the-badge&>"/></a>
 
 **[(Frontend-end github)](https://github.com/Team-EYAGI/Front)** 

  <br />
 <br />

#### `Designer`
<a href="https://www.behance.net/lia_works" target="_blank"><img height="40"  src="https://img.shields.io/static/v1?label=Design&message=이아영 &color=F55C54&style=for-the-badge&>"/></a>
<a href="https://seo-jyun-0731.tistory.com/ 
https://blog.naver.com/seojyun0731" target="_blank"><img height="40"  src="https://img.shields.io/static/v1?label=Design&message=서지윤 &color=F55C54&style=for-the-badge&>"/></a>

<br>


## 아키텍처(Architecture)
<p align="center">
<img src="https://user-images.githubusercontent.com/61370487/171578575-f5fdb814-1d71-434f-9879-cc9004432ef7.png">
</p>

## 🛠 기술스택
<p align="center">
<!-- spring -->
<img src="https://img.shields.io/badge/Spring-6DB33F?style=for-the-badge&logo=Spring&logoColor=white">
<img src="https://img.shields.io/badge/spring data jpa-F28D1A?style=for-the-badge&logo=springdatajpa&logoColor=white">
<img src="https://img.shields.io/badge/spring security-6DB33F?style=for-the-badge&logo=springsecurity&logoColor=white">
<br>
<!-- java mysql gradle -->
<img src="https://img.shields.io/badge/gradle-02303A?style=for-the-badge&logo=gradle&logoColor=white">
<img src="https://img.shields.io/badge/JAVA-007396?style=for-the-badge&logo=java&logoColor=white">
<img src="https://img.shields.io/badge/Jsoup-981E32?style=for-the-badge&logo=java&logoColor=white">
<img src="https://img.shields.io/badge/mysql-4479A1?style=for-the-badge&logo=mysql&logoColor=white">
<br>
<!-- aws -->
<img src="https://img.shields.io/badge/aws ec2-07C160?style=for-the-badge&logo=amazoneaws&logoColor=white">
<img src="https://img.shields.io/badge/amazons3-569A31?style=for-the-badge&logo=amazons3&logoColor=white">
<br>
<!-- git -->
<img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white">
<img src="https://img.shields.io/badge/git-F05032?style=for-the-badge&logo=git&logoColor=white">
<!-- redis -->
<img src="https://img.shields.io/badge/redis-DC382D?style=for-the-badge&logo=redis&logoColor=white">
<img src="https://img.shields.io/badge/stomp-000000?style=for-the-badge&logo=stomp&logoColor=white">
<img src="https://img.shields.io/badge/SockJS-7D929E?style=for-the-badge&logo=sockJS&logoColor=white">
<!-- docker -->
<img src="https://img.shields.io/badge/docker-2496ED?style=for-the-badge&logo=docker&logoColor=white">
<!-- zenkins -->
<img src="https://img.shields.io/badge/jenkins-D24939?style=for-the-badge&logo=jenkins&logoColor=white">
  
<br>

## ERD

 ## :pushpin: 아키텍처 도입과정
  
 <details>
<summary>springboot</summary>
<div markdown="1">
  
  
  spring boot는 spring을 개발자들이 좀 더 편리하게 개발에 집중할 수 있도록 개선된 프레임워크입니다.
    
 기존 spring 같은 경우, 의존성을 추가해주려면 내가 사용하려는 것의 버전에 대한 정보까지 일일이 맞추어야하고 정말 긴 dependency를 작성해야했지만,
  boot에서는 자동으로 권장 버전을 체크해주기 때문에  starter 한 줄만으로 dependency를 설정할 수 있게 되었습니다.
    
톰캣도 내장이 되어 있어서 따로 설치할 필요 없이 사용이 가능하기 때문에 초기에 구축하는 시간을 단축시켜 주고, 매번 버전관리를 해야하는 수고도 덜어줍니다.
또한 내장 된 서블릿 컨테이너 덕분에 jar 파일 하나로 쉽게 배포 서버를 구축 할 수 있습니다.
  
  
  마지막으로 저희는 스프링 시큐리티를 이용해서 보안체계를 맞추려고 하였고, Boot에서는 이러한 프레임워크들의 요소를 쉽게 사용할 수 있기 때문에 기존의 spring이 아닌, spring Boot를 사용하였습니다.
  
boot를 사용하며 ORM이 가능한 JPA도 사용해서 SQL 사용을 보다 간편하게 하고자 하였습니다.

</div>
</details>

  <details>
<summary>jsoup</summary>
<div markdown="1">

  
 처음에는 크롤링을 해서 데이터를 구축해놓는 방식이 아닌, 도서 검색 api를 활용해서 도서 정보를 가져오는 방법을 생각하였습니다. 
 등록하고자 하는 오디오북을 검색하도록 하고 , 오디오북을 등록함과 동시에 검색한 도서의 정보를 DB에 저장 시키는 방법을 고민해보았지만 사용자 입장에서 여러 에로사항이 생길 것 같았습니다. 
    
  
  특히, 오디오를 듣고싶어하는 사용자가 유입되었을 때 서점처럼 눈에 보여지는 도서들이 없다면 , 특정 도서에 대해 오디오로 듣고싶다는 흥미를 유발 시키기 어렵다고 판단하였습니다.  
    
 또한, 데이터가 없는 상태라면 서비스를 처음 접하는 사용자들은 세상 수 많은 도서 중 원하는 특정 도서를 골라야만 하므로, 
  결국 과도한 많은 선택지를 주게 되는 것이라고 판단하였고, 그렇게 하기보단 일정 선택의 범위를 제공하여 선택의 역설에 대한 상황을 없애고자 하였습니다. 그래서 직접 웹크롤링을 통해서 인기가 있고 유명한 책들을 적당한 양의 도서들을 가져오기로 결정했습니다. 
    
  
 크롤링이라면 보통 python을 많이 이용하지만,  그래도 현재 사용하는 언어가 java이기 때문에  java를 가지고 크롤링을 해보고싶어서 HTML을 파싱해주는 JAVA 오픈 소스 라이브러리인 jsoup을 사용해서 웹 크롤링을 진행하였습니다.

</div>
</details>
  
<details>
<summary>MySQL</summary>
<div markdown="1">

  
 제작하려고 한 서비스에는 회원관리와 도서에 대한 데이터 관리가 필수이므로 , 데이터 중복이 없는 RDBMS를 사용하고자 하였고 
  jpa를 사용한 테이블간의 매핑을 이용하기위해서는 역시 RDBMS를 사용해야겠다 라고 판단하였습니다.
    
 여러 RDBMS가 있지만, 아무래도 보편적으로 많이 사용되는 MYSQL이 눈에 띄었고, MYSQL을 기반으로 만들어진 MariaDB 또한 고민이 되었습니다. 
  
  
 MariaDB가 MYSQL 이 점이 많다는 이야기를 많이 접했지만, 아직은 MySQL의 사용도가 더 높아, 상대적으로 좀 더 많은 레퍼런스가 존재하기 때문에 MySQL을 사용해보고자 하였고 ,
    
MariaDB가 MySQL에서 파생되었기 때문에 근본이 되는 MySQL을 먼저 사용해본다면 MariaDB 역시 어렵지 않게 학습 할 수 있을 것 같다고 판단하여 MYSQL을 채택하였습니다. 
    
오디오파일이나 이미지파일 같은 경우는 AWS S3에 업로드해주었습니다.
    

</div>
</details>
    
<details>
<summary>Jenkins & Docker</summary>
<div markdown="1">

  
 CI tool 의 다양한 선택지 중 저희가 고려했던 조건들은 
+ 적은 비용
+ AWS EC2에 배포가능
+ Git 과의 연동
+ 비교적 낮은 러닝 커버
    
    이 었습니다.
 찾아보았던 것들 중 유료인 것들은 전부 배재하고 , 100%오픈소스이기에 많은 플러그인까지 갖춘 **젠킨스,** 
  깃헙과 연동시 좋은 퍼포먼스를 보여주는 Travis CI, 작은 프로젝트에서 사용하기 좋다는 GitActions 셋 중 고민을 하였습니다. 
  
  
  그 중 비교적 러닝커버가 낮아보이는건 깃 액션이였습니다. github을 사용한다면 아무래도 규모가 크지 않는 프로젝트에서는 GitActions사용하는 것도 좋은 방법이라고 생각하나  현업에서 많이 사용한다는 젠킨스에 한번 도전해보고자 하였습니다. 처음 고려했던 조건 중 비교적 낮은 러닝커버가 있었지만, 젠킨스는 오픈소스이기 때문에 사용자도 많고, 그에 따라 레퍼런스도 많아서 한 번 해보자 라는 생각이 들어 도전해보았습니다.
    

    도커 사용 같은 경우는 , 도커는 파일들을 모두 하나의 컨테이너에 담기 때문에 한 곳에 문제가 생겨도 서로 영향을 주지 않으며 도커만 있다면 손쉽게 관리 및 이동이 가능하여 보다 어떤 서버 환경에서도 유연한 관리가 가능하기 때문에 도커를 이용해서 Redis, 그리고 Jenkins 소프트웨어 패키지를 도커를 통해 이용해보고자 하였습니다.

</div>
</details>
    
  
  <details>
<summary>Redis</summary>
<div markdown="1">


 채팅의 경우 진행되면 한명에 최소 수십개, 이후 최대 수백개의 데이터가 요청되며 실시간으로 진행 될 경우 수없이 많은 mysql에 요청과 요구가 진행 될 것입니다. 
그렇게 된다면 많은 SQL문의 처리 요청으로 서버에서 동시에 진행 할 수 있는 처리 한계치를 넘어서게 되고 운영업체에서는 DB서버에 많은 메모리 증가, CPU증설을 해야 하는 상황이 발생할 수 있습니다.
    
  MySQL 서버의 성능 문제로 서버가 중단되면 서버교체 비용과 서비스가 중단되는 지점이 생기고 임계치를 넘어갈 때마다 매번 작업을 진행해야 할 것 입니다. 
 하지만 캐시에 저장하는 인메모리 구조의 레디스를 사용한다면 실시간 채팅에서 mySQL로의 지속적인 SQL문 생성을 막을 수 있을 것이라고 생각했습니다.
    
 Redis는 다음과 같은 특징을 지닙니다.
    
 + In-memory 데이터 저장소: 디스크에 데이터를 저장하는 다른 데이터베이스들(PostgreSQL, MongoDB 등)과 달리 데이터를 메모리에 위치시킴으로서 속도면에서 우위를 점함.
 + 유연한 데이터 구조: Key-Value 구조이외에도 다양한 데이터 구조를 지원함.
 + 단순성 및 사용 편의성
 + 복제 및 지속성
 + 높은 가용성 및 확장성(Scale-up, Scale-out)
 + 확장성: 오픈 소스인 만큼 공급업체 기술 종속적이지 않음 (Spring 지원)
    
    다음과 같은 장점들을 고려해 , 레디스를 사용하여 채팅을 개발하였습니다.

</div>
</details>
    

  <details>
<summary>Stomp</summary>
<div markdown="1">

  
   Stomp는 Simple Text Oriented Messaging Protocol의 약자로, Websocket 위에서 동작하는 텍스트 기반 메세징 프로토콜입니다.
 Publish-Subscribe 매커니즘을 제공하기 때문에 Broket을 통해서 다른 사용자에게 메세지를 보내거나 서버가 특정 작업을 수행하도록 메세지를
보낼 수 있습니다. 또한 Http와 마찬가지로 frame을 사용해 전송하는 프로토콜입니다.
  
   각 커넥션마다 websocketHandler를 구현하여 사용하기 보다 Controller Annotation이 적용된 객체를 이용해 조직적으로 관리할 수 있습니다.    
예를 들어 @MessageMapping을 이용하여 Controller객체에 라우팅 시킬 수 있습니다. 또한 Stomp의 URI경로인 Destiantion을 기반으로 Spring Security를 적용해 메세지를 보호할 수 있습니다. 즉 메세징 프로토콜과 메세징 형식을 개발할 필요가 없어집니다.
 ps) Frame은 명령과 추가적인 헤더, 바디로 구성이 됩니다. 이는 첫번째 라인에는 텍스트(Command)이고 이후 key:value형태로 헤더정보를 포함합니다.

</div>
</details>

  
## 🎨 트러블 슈팅
### Back-End 트러블슈팅
 <details>
<summary>비회원 / USER / SELLER / ADMIN 권한 별 api 제어</summary>
<div markdown="1">


사이트 특성상 회원별로 역할이 다르게 되어있습니다. 비회원 / 일반 회원 = USER / 오디오를 등록할 수 있는 = SELLER / 관리자 = ADMIN. 

역할이 다르기 때문에 수행할 수 있는 액션도 다르게 정해져 있습니다. 예를 들면 오디오를 등록한다거나 (user와 seller의 차이) 마이페이지에 들어간다거나 (비회원과 회원의 차이) . . 그렇기 때문에 비회원은 마이페이지를 들어갈 수 없고 관리자가 아닌 회원들은 관리자 페이지에 접속 할 수 없어야합니다. 하지만 혹시 몰라 테스트로 , 주소창에 관리자 페이지 url 를 입력했을 때, 페이지가 이동이 되는 현상이 발생했습니다. 제한을 두지 않았기에 당연한 현상이였습니다. 

<aside>

💡 올바르지 않은 권한에 대해 예외를 발생시킬때에는 어차피 입장부터 불가능한것이기 때문에 컨트롤러 단보다 더 앞쪽에서 처리해주는 것이 효율적이지 않을까?


</aside>

→  권한을 제어할 수 있는 어노테이션을 제작. HandlerInterceptor를 구현하여 해당 어노테이션을 적용시켜줌. 

→  제작한 어노테이션을 권한이 필요한 api에만 적용시켜준다.

- HandlerInterceptor 구현 작성 코드
    
    ```java
    public class AuthInterceptor implements HandlerInterceptor {
        
        private  final JwtDecoder jwtDecoder;
    
        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
                throws Exception {
            Auth Auth = null;
    
            // 현재 입력으로 들어온 메소드가 어노테이션이 붙어있는지 확인 후 그렇지 않으면 그냥 넘어감.
            if (!(handler instanceof HandlerMethod)) {
                return true;
            }
            //어노테이션이 포함되어 있는지 검사
            HandlerMethod hm = (HandlerMethod) handler;
            Auth = ((HandlerMethod) handler).getMethodAnnotation(Auth.class);
            // 제작한 어노테이션 없는 경우
            if (Auth == null) {
                return true;
            }
            //헤더에서 토큰을 꺼내옴. 
            final String header = request.getHeader("Authorization");
    
            final String HEADER_PREFIX = "Bearer ";
    
            String role =jwtDecoder.decodeUserRole( header.substring(
                    HEADER_PREFIX.length(),
                    header.length()
            ));
            /*
            비회원의 경우, 시큐리티에서 토큰 유무를 따기지 때문에 굳이 만들 필요 없음.
             user이면 예외 발생. => seller 혹은 admin만 가능. 
            제작한 어노테이션에 admin이라고 적혀있다면, 접속을 시도한 유저의 role도 admin 이여야함. 
             user와 admin권한 조건문으로 제한을 둠으로써 seller에 대한 처리가 자동으로 되었음.
             */
            if(role.equals("ROLE_USER")){
                throw new IllegalAccessException("권한이 없습니다.");
            }
            if(Auth.authority()==UserRole.ADMIN){
                if(!role.equals("ROLE_ADMIN")){
                    throw new IllegalAccessException("관리자 권한이 없습니다.");
                }
            }
            return true;
        }
    }
    ```
   </div>
</details>
  
 <details>
<summary>오디오 파일 편집시, < 다른 프로세스가 파일을 사용 중이기 때문에 프로세스가 엑세스 할 수 없습니다. > 라는 예외 발생.
</summary>
<div markdown="1">


사용자가 오디오북의 첫 파일을 업로드할 때 , 사용자가 올린 오디오 파일을 편집하여 1분 미리듣기를 제공하고 있습니다. 

이 과정이 오디오파일을 올림과 동시에 일어나게 됩니다. 동시에 로직이 진행되지만, 제가 생각한 로직의 순서는

1. 오디오 파일을 S3에 업로드 
2. 오디오파일을 받아서 1분 미리듣기로 편집 
    
    (저희는 MultpartFile로 파일을 받고 있지만, java 에서 오디오를 편집하려면 자료형이 File 이여야하므로 inputStream을 이용하여 받아온 MultpartFile을 읽어드려 File로 형변환 하는 과정을 거칩니다. 그리고 그 과정에서 로컬에 형변환 된 파일이 저장이됩니다. 그리고 그 파일을 가지고 1분 편집을 하게 됩니다. 즉, 형변환 되어 로컬에 저장이 되는 이 파일은 로직 수행이 끝나고 나면 자리만 차지하는 불필요한 파일이 됩니다.)
    
3. 1분 미리듣기 파일을 S3에 업로드 
4. 로컬에 남게된 불필요한 파일을 삭제. 

이렇게 였으나, 아무래도 파일을 편집을 하는 과정이 다른 로직보다 시간이 오래 걸려서 , 생각했던 것 처럼 순서대로 로직이 실행되지 않고 , 파일 편집이 채 끝나기도 전에 삭제시키는 로직이 실행이 되어 발생하는 문제였습니다.

<aside>

💡 로직들을 내가 원하는 순서대로 딱딱 떨어지게 실행 시킬 수는 없을까 ?


</aside>

순서대로 실행시킬 수 있는 것을 찾아보던 중 , 쓰레드 우선순위라는 것을 보았습니다. 그러나 우선순위를 지정한다고 해도 우선순위 앞에 있는 쓰레드가 작업이 다 끝나고 나면 다름 쓰레드가 실행이 되는 것이 아니라 , 서로 조금씩 주고받으며 실행이 되는 것이고 쓰레드 작업은 자바가 아닌, 운영체제에서 관리하는 것이기 때문에 백번을 시도했을 때 백번 모두 내가 원하는 결과가 나오지 않을 수 있다고 확인하였습니다.

쓰레드 슬립에 대한 이야기도 많았지만, 오디오 편집이 파일 크기마다 혹은, 주입되는 사용자에 따라 작업 시간이 달라질 수 있기때문에 그 방법은 적절하지 않다고 판단하였습니다.

그래서 저는

⇒ 오디오 파일 편집만을 진행해 줄 쓰레드를 생성.

→ 해당 쓰레드가 작업을 끝마칠때까지 메인 쓰레드가 기다릴 수 있도록 쓰레드 조인 메서드를 사용.

이렇게 해결하였습니다.
  
  </div>
</details>
  
<details>
<summary>쿼리 N + 1 개선</summary>
<div markdown="1">


RDBMS를 사용하고 있는 만큼, 장점을 살려 연관관계를 여럿 맺고 구현을 하였습니다. 

JPA가 등장함에 따라 자동화된 쿼리문들이 생겨나면서 어쩔 수 없이 발생하는 문제입니다. JPA의 경우에는 객체에 대해서 조회한다고 해도 다양한 연관관계들의 매핑에 의해서 관계가 맺어진 다른 객체가 함께 조회되는 경우에 N+1이 발생하게 됩니다.

(Fetch type은 default로 **~ToMany에서는 Lazy**, **~ToOne에서는 Eager**로 지정)

즉시로딩은 Jpql로 전달되는 과정에서 Jpql 후 Eager 감지로 인한 N쿼리가 추가로 발생하는 경우가 있기 때문에 사용해서는 안된다.

N + 1 을 제어하는 방법에는 크게 2가지 정도가 있습니다.

- fetch join 사용.
    1. 일단 즉시로딩에서는 우리가 커스텀할 수 있는 부분이 존재하지 않기 때문에 지연로딩 과정에서 우리는 바로 사용을 할 객체에 대해서는 join을 걸 수 있도록 조정해주어야 합니다. 그것이 fetch join입니다.
    2. join문에 fetch를 걸어주어 사용하는 fetch는 지연 로딩이 걸려있는 연관관계에 대해서 한번에 같이 즉시로딩해주는 구문입니다.
    
    예시로는 Jpql, QueryDsl두가지 방법으로 사용할 수 있습니다.
    
- @EntityGraph 사용.
    
    jpql에서 fetch join을 하게 된다면 하드코딩을 하게 된다는 단점이 있습니다. 이를 최소화하고싶다면 `@EntityGraph`
    를 사용하면 됩니다.
    
    Spring JPA 2.1부터 지원하기 시작한 annotation으로 엔티티의 연관된 관계를 로딩할때 성능을 높여주기 위해 나온 것입니다. 즉, 하나의 select query로 조회가 되도록 지원합니다.
    
- Jpql과 FetchJoin을 도입하여 개선한 코드
 ![image](https://user-images.githubusercontent.com/61370487/172021187-e1ede9bd-23fa-4ae7-a012-7ce9d821d88e.png)
 ![image](https://user-images.githubusercontent.com/61370487/172021262-83a1afaf-57f8-45f3-8a02-fa2de262ca59.png)   

    
- @EntityGraph 를 적용하여 개선해본 경우
 ![image](https://user-images.githubusercontent.com/61370487/172021276-adcdda31-f1f0-46ec-bbec-5323a235b7ac.png)

    

- 실행된 쿼리문 비교
    
    우 - 개선된 쿼리 / 좌 - 개선전 쿼리 .
    

    

|  | mapping | 요청수 | Min /ms | Max /ms | Average /ms | Error % | Throughput /sec |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 개선 전 | /main/fund | 총 5000(500 1 10) | 529 | 46395 | 24047 | 0.04% | 19.6 |
| 개선 후 |  | 총 5000(500 1 10) | 27 | 5254 | 1772 | 0.00% | 257.1 |
| 개선 전 | /user/todayCreator | 총 5000(500 1 10) | 1149 | 41535 | 22249 | 0.00% | 21.2 |
| 개선 후 |  | 총 5000(500 1 10) | 14 | 4453 | 966 | 0.00% | 400.7 |
| 개선 전 | /fund/detail/1 | 총 5000(500 1 10) | 77 | 10822 | 4256 | 0.00% | 110.0 |
| 개선 후 |  | 총 5000(500 1 10) | 9 | 2871 | 747 | 0.00% | 534.6 |
  
  </div>
</details>
   
<details>
<summary>DB검색 최적화를 위한 인덱싱</summary>
<div markdown="1">

n+1을 개선하며 , 조금 더 나은 성능 향상을 위해서 인덱싱까지 시도해보기로 하였습니다.

어떠한 컬럼값으로 인덱싱을 하는 것이 가장 효율적일까를 고민하며 , 각 테이블들의 카디널리티 측정 테스트를 해보았고 해당 결과를 바탕으로 인덱싱을 적용하였습니다.
![image](https://user-images.githubusercontent.com/61370487/172021294-2d867d49-ea89-44c1-9d3c-629ba1461b5c.png)



인덱싱 적용

![image](https://user-images.githubusercontent.com/61370487/172021315-d29d320d-e83c-445b-a2d6-f71925389086.png)


그리고 jmeter를 사용하여 부하테스트를 진행하면서 n+1 과 인덱싱 작업 이후 성능 개선이 얼마나 되었는지 체크해보았습니다.

+ 개선 전

| mapping | 요청수 | Min /ms | Max /ms | Average /ms | Error % | Throughput /sec |
| --- | --- | --- | --- | --- | --- | --- |
| /main/fund | 총 5000(500 1 10) | 529 | 46395 | 24047 | 0.04% | 19.6 |
| /user/todayCreator | 총 5000(500 1 10) | 1149 | 41535 | 22249 | 0.00% | 21.2 |
| /fund/detail/1 | 총 5000(500 1 10) | 77 | 10822 | 4256 | 0.00% | 110.0 |

+ n + 1 개선 후

| mapping | 요청수 | Min /ms | Max /ms | Average /ms | Error % | Throughput /sec |
| --- | --- | --- | --- | --- | --- | --- |
| /main/fund | 총 5000(500 1 10) | 27 | 5254 | 1772 | 0.00% | 257.1 |
| /user/todayCreator | 총 5000(500 1 10) | 14 | 4453 | 966 | 0.00% | 400.7 |
| /fund/detail/1 | 총 5000(500 1 10) | 9 | 2871 | 747 | 0.00% | 534.6 |

+ 인덱싱 작업 후

| mapping | 요청수 | Min /ms | Max /ms | Average /ms | Error % | Throughput /sec |
| --- | --- | --- | --- | --- | --- | --- |
| /main/fund | 총 5000(500 1 10) | 19 | 4937 | 1518 | 0.00% | 281.6 |
| /user/todayCreator | 총 5000(500 1 10) | 14 | 3826 | 881 | 0.00% | 525.5 |
| /fund/detail/1 | 총 5000(500 1 10) | 8 | 2164 | 575 | 0.00% | 831.7 |

<details>
<summary>Nginx를 통한 블루 그린 배포 인프라 설정</summary>
<div markdown="1">


nginx를 통해서 80, 443 요청을 Https 한 가지 경로로 라우팅 할 수 있도록 설정하였습니다. 리버스 프록시를 설정하는 proxy_pass로 경로 지정 및, cache 설정, 권한 등을 위한 세팅은 마쳤습니다. 재실행을 해보니 Console 창에 아래와 같은 문구를 확인하였습니다.
![image](https://user-images.githubusercontent.com/61370487/172021385-f4ef22c8-95ee-4da4-9db7-7ba1ebee6330.png)

```
Error during WebSocket handshake: Unexpected response code: 400
```

해당 내용을 확인해보니 웹소켓 연결시에 웹소켓 클라이언트에서 핸드쉐이크 응답을 받는 프로토콜 전환을 서버가 승인해 주는 부분에서 리버스 프록시 설정이 부족하다는 것을 확인 하였고, 이는 클라이언트에서 Upgrade 승인을 받지 못했다고 판단하여 nginx의 conf 파일에 아래 코드를 추가 해줌으로써 해결 하였습니다. 

```jsx
proxy_set_header Upgrade "$http_upgrade";
proxy_set_header Connection "upgrade";
```
![image](https://user-images.githubusercontent.com/61370487/172021425-4d1350b2-3561-4329-b47c-2f438f6c3c1f.png)
</div>
</details>


