<p align="center">
<img src="https://user-images.githubusercontent.com/61370487/171013112-796a9d06-6b91-4012-9af7-ee9ccfb20eaf.png" alt="pick-git-logo" width="300" height="300">
</p>
<div align="center">
  
💻 다양한 사람들의 목소리를 연결하는 오디오북 사이트</br>
🌏 [이야기 (eyagi)](https://www.eyagibook.shop/)

</div>
<div align="center">
  
<a href="https://balanced-desk-3a4.notion.site/EYAGI-06e6113484324fe8ba37ec83e5e70b8d"><img src="https://img.shields.io/badge/Notion-%23000000.svg?style=for-the-badge&logo=notion&logoColor=white&link=https://balanced-desk-3a4.notion.site/EYAGI-06e6113484324fe8ba37ec83e5e70b8d/"/></a>
<a href="https://www.instagram.com/_eyagi_"><img src="https://img.shields.io/badge/Instagram-%23E4405F.svg?style=for-the-badge&logo=Instagram&logoColor=white&link=https://www.instagram.com/_eyagi_/"/></a>

  
</div>
<br/>

## 🙌 프로젝트 소개
 저희 EYAGI(이야기)에서는
책을 "듣고 싶은 사람"이 원하는 취향의 목소리와 낭독 스타일을 찾아 책을 들으며 낭독자에게 반응을 주고, 듣고싶은 책이 있다면 오디오북으로 요청글을 올릴 수도 있습니다.

자신의 목소리를 "들려주고 싶은 사람"은 오디오북으로 등록하고 싶은 책을 찾아, 펀딩을 신청하면 자신에게 달리는 사람들의 호감도를 확인 할 수 있고, 그로 인해 얼마나 많은 사람들이 내 오디오를 들어줄지 확인 한 후, 오디오북 "연재"를 시작할 수 있습니다. (펀딩 신청시, 목표치를 정하고 달성이 되면 연재를 시작합니다! )
이렇게 "듣고 싶은 사람"과 "들려주고 싶은 사람이" 함께 상부상조하는 오디오북 서비스입니다.

여러 사람들이 올려놓은 재밌는 오디오북도 들어보고!
크리에이터(낭독자)로 전환 신청하여 자신의 목소리를 세상 밖에 들려주세요!

## :books: eyagi(이야기)
|메인 페이지|오디오북 페이지|댓글|
|:-:|:-:|:-:|
|<img src=https://user-images.githubusercontent.com/61370487/171026913-adb69bee-9171-4b12-b273-8f1a5fe828f3.gif>|<img src=https://user-images.githubusercontent.com/61370487/171030696-98bbaa9e-347b-4633-956c-77462db17670.gif>|<img src=https://user-images.githubusercontent.com/61370487/171026534-71d090f4-0d17-465b-aa59-c2384232e88c.gif>|
|<b>팔로우</b>|<b>오디오북요청</b>|<b>채팅</b>|
|<img src=https://user-images.githubusercontent.com/61370487/171026610-b4584b86-0174-4c28-ae57-b25fe1f561f8.gif>|<img src=https://user-images.githubusercontent.com/61370487/171030045-42a40812-b807-4b52-ab75-199d88a075eb.gif>|<img src=https://user-images.githubusercontent.com/61370487/171029947-8c62bbd1-fe94-41f6-9714-0a08e9e63151.gif>|
|<b>펀딩</b>|<b>검색</b>|<b>마이페이지</b>|
|<img src=https://user-images.githubusercontent.com/61370487/171026925-7215b3f8-7369-4f58-a4f6-bd57493b21ed.gif>|<img src=https://user-images.githubusercontent.com/61370487/171030108-3e4bc940-20ff-497a-9484-e920b958cef9.gif>|<img src=https://user-images.githubusercontent.com/61370487/171030132-8b300843-90f0-4e72-8271-933c75026aff.gif>|

## 👨‍💻👩‍💻 팀원 소개
#### `Backend`
<a href="https://github.com/EunheaSong" target="_blank"><img height="40"  src="https://img.shields.io/static/v1?label=Spring&message=송은혜 &color=08CE5D&style=for-the-badge&>"/></a>
<a href="https://github.com/akrwkdrrr99" target="_blank"><img height="40"  src="https://img.shields.io/static/v1?label=Spring&message=김승균 &color=08CE5D&style=for-the-badge&>"/></a>
<a href="https://github.com/yunju2" target="_blank"><img height="40"  src="https://img.shields.io/static/v1?label=Spring&message=권윤주 &color=08CE5D&style=for-the-badge&>"/></a>


<br>

#### `Frontend`
<a href="https://github.com/JIEUN24" target="_blank"><img height="40"  src="https://img.shields.io/static/v1?label=React&message=최지은 &color=61dafb&style=for-the-badge&>"/></a>
<a href="https://github.com/hyopp" target="_blank"><img height="40"  src="https://img.shields.io/static/v1?label=React&message=권효빈 &color=61dafb&style=for-the-badge&>"/></a>
 
 **[(Frontend-end github)](https://github.com/Team-EYAGI/Front)** 

  <br />
 <br />

#### `Designer`
<a href="https://www.behance.net/lia_works" target="_blank"><img height="40"  src="https://img.shields.io/static/v1?label=Design&message=이아영 &color=F55C54&style=for-the-badge&>"/></a>
<a href="https://seo-jyun-0731.tistory.com/ 
https://blog.naver.com/seojyun0731" target="_blank"><img height="40"  src="https://img.shields.io/static/v1?label=Design&message=서지윤 &color=F55C54&style=for-the-badge&>"/></a>

<br>


## 아키텍처(Architecture)
<p align="center">
<img src="https://user-images.githubusercontent.com/61370487/171578575-f5fdb814-1d71-434f-9879-cc9004432ef7.png">
</p>

## 🛠 기술스택
<p align="center">
<!-- spring -->
<img src="https://img.shields.io/badge/Spring-6DB33F?style=for-the-badge&logo=Spring&logoColor=white">
<img src="https://img.shields.io/badge/spring data jpa-F28D1A?style=for-the-badge&logo=springdatajpa&logoColor=white">
<img src="https://img.shields.io/badge/spring security-6DB33F?style=for-the-badge&logo=springsecurity&logoColor=white">
<br>
<!-- java mysql gradle -->
<img src="https://img.shields.io/badge/gradle-02303A?style=for-the-badge&logo=gradle&logoColor=white">
<img src="https://img.shields.io/badge/JAVA-007396?style=for-the-badge&logo=java&logoColor=white">
<img src="https://img.shields.io/badge/Jsoup-981E32?style=for-the-badge&logo=java&logoColor=white">
<img src="https://img.shields.io/badge/mysql-4479A1?style=for-the-badge&logo=mysql&logoColor=white">
<br>
<!-- aws -->
<img src="https://img.shields.io/badge/aws ec2-07C160?style=for-the-badge&logo=amazoneaws&logoColor=white">
<img src="https://img.shields.io/badge/amazons3-569A31?style=for-the-badge&logo=amazons3&logoColor=white">
<br>
<!-- git -->
<img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white">
<img src="https://img.shields.io/badge/git-F05032?style=for-the-badge&logo=git&logoColor=white">
<img src="https://img.shields.io/badge/github actions-2088FF?style=for-the-badge&logo=github actions&logoColor=white">
<!-- redis -->
<img src="https://img.shields.io/badge/redis-DC382D?style=for-the-badge&logo=redis&logoColor=white">
<img src="https://img.shields.io/badge/stomp-000000?style=for-the-badge&logo=stomp&logoColor=white">
<img src="https://img.shields.io/badge/SockJS-7D929E?style=for-the-badge&logo=sockJS&logoColor=white">
<!-- docker -->
<img src="https://img.shields.io/badge/docker-2496ED?style=for-the-badge&logo=docker&logoColor=white">
<!-- zenkins -->
<img src="https://img.shields.io/badge/jenkins-D24939?style=for-the-badge&logo=jenkins&logoColor=white">
  
<br>

## ERD

 ## :pushpin: 아키텍처 도입과정
  
 <details>
<summary> **springboo** </summary>
<div markdown="1">

  spring boot는 spring을 개발자들이 좀 더 편리하게 개발에 집중할 수 있도록 개선된 프레임워크입니다.
    
    기존 spring 같은 경우, 의존성을 추가해주려면 내가 사용하려는 것의 버전에 대한 정보까지 일일이 맞추어야하고 정말 긴 dependency를 작성해야했지만, boot에서는 자동으로 권장 버전을 체크해주기 때문에  starter 한 줄만으로 dependency를 설정할 수 있게 되었습니다.
    
    톰캣도 내장이 되어 있어서 따로 설치할 필요 없이 사용이 가능하기 때문에 초기에 구축하는 시간을 단축시켜 주고, 매번 버전관리를 해야하는 수고도 덜어줍니다.
    
    또한 내장 된 서블릿 컨테이너 덕분에 jar 파일 하나로 쉽게 배포 서버를 구축 할 수 있습니다.
    
    마지막으로 저희는 스프링 시큐리티를 이용해서 보안체계를 맞추려고 하였고, Boot에서는 이러한 프레임워크들의 요소를 쉽게 사용할 수 있기 때문에 기존의 spring이 아닌, spring Boot를 사용하였습니다.
    
    boot를 사용하며 ORM이 가능한 JPA도 사용해서 SQL 사용을 보다 간편하게 하고자 하였습니다.

</div>
</details>

  <details>
<summary> **jsoup** </summary>
<div markdown="1">

    처음에는 크롤링을 해서 데이터를 구축해놓는 방식이 아닌, 도서 검색 api를 활용해서 도서 정보를 가져오는 방법을 생각하였습니다. 등록하고자 하는 오디오북을 검색하도록 하고 , 오디오북을 등록함과 동시에 검색한 도서의 정보를 DB에 저장 시키는 방법을 고민해보았지만 사용자 입장에서 여러 에로사항이 생길 것 같았습니다. 
    
    특히, 오디오를 듣고싶어하는 사용자가 유입되었을 때 서점처럼 눈에 보여지는 도서들이 없다면 , 특정 도서에 대해 오디오로 듣고싶다는 흥미를 유발 시키기 어렵다고 판단하였습니다.  
    
    또한, 데이터가 없는 상태라면 서비스를 처음 접하는 사용자들은 세상 수 많은 도서 중 원하는 특정 도서를 골라야만 하므로, 결국 과도한 많은 선택지를 주게 되는 것이라고 판단하였고, 그렇게 하기보단 일정 선택의 범위를 제공하여 선택의 역설에 대한 상황을 없애고자 하였습니다. 그래서 직접 웹크롤링을 통해서 인기가 있고 유명한 책들을 적당한 양의 도서들을 가져오기로 결정했습니다. 
    
    크롤링이라면 보통 python을 많이 이용하지만,  그래도 현재 사용하는 언어가 java이기 때문에  java를 가지고 크롤링을 해보고싶어서 HTML을 파싱해주는 JAVA 오픈 소스 라이브러리인 jsoup을 사용해서 웹 크롤링을 진행하였습니다.

</div>
</details>
  
<details>
<summary> **MySQL** </summary>
<div markdown="1">

    제작하려고 한 서비스에는 회원관리와 도서에 대한 데이터 관리가 필수이므로 , 데이터 중복이 없는 RDBMS를 사용하고자 하였고 jpa를 사용한 테이블간의 매핑을 이용하기위해서는 역시 RDBMS를 사용해야겠다 라고 판단하였습니다.
    
    여러 RDBMS가 있지만, 아무래도 보편적으로 많이 사용되는 MYSQL이 눈에 띄었고, MYSQL을 기반으로 만들어진 MariaDB 또한 고민이 되었습니다. MariaDB가 MYSQL 이 점이 많다는 이야기를 많이 접했지만, 아직은 MySQL의 사용도가 더 높아, 상대적으로 좀 더 많은 레퍼런스가 존재하기 때문에 MySQL을 사용해보고자 하였고 ,
    
    MariaDB가 MySQL에서 파생되었기 때문에 근본이 되는 MySQL을 먼저 사용해본다면 MariaDB 역시 어렵지 않게 학습 할 수 있을 것 같다고 판단하여 MYSQL을 채택하였습니다. 
    
    오디오파일이나 이미지파일 같은 경우는 AWS S3에 업로드해주었습니다.
    

</div>
</details>
    
<details>
<summary> **Jenkins & Docker** </summary>
<div markdown="1">

    CI tool 의 다양한 선택지 중 저희가 고려했던 조건들은 
    
    - 적은 비용
    - AWS EC2에 배포가능
    - Git 과의 연동
    - 비교적 낮은 러닝 커버
    
    이 었습니다.
    
    찾아보았던 것들 중 유료인 것들은 전부 배재하고 , 100%오픈소스이기에 많은 플러그인까지 갖춘 **젠킨스,**  깃헙과 연동시 좋은 퍼포먼스를 보여주는 Travis CI, 작은 프로젝트에서 사용하기 좋다는 GitActions 셋 중 고민을 하였습니다. 그 중 비교적 러닝커버가 낮아보이는건 깃 액션이였습니다. github을 사용한다면 아무래도 규모가 크지 않는 프로젝트에서는 GitActions사용하는 것도 좋은 방법이라고 생각하나  현업에서 많이 사용한다는 젠킨스에 한번 도전해보고자 하였습니다. 처음 고려했던 조건 중 비교적 낮은 러닝커버가 있었지만, 젠킨스는 오픈소스이기 때문에 사용자도 많고, 그에 따라 레퍼런스도 많아서 한 번 해보자 라는 생각이 들어 도전해보았습니다.
    
    도커 사용 같은 경우는 , 도커는 파일들을 모두 하나의 컨테이너에 담기 때문에 한 곳에 문제가 생겨도 서로 영향을 주지 않으며 도커만 있다면 손쉽게 관리 및 이동이 가능하여 보다 어떤 서버 환경에서도 유연한 관리가 가능하기 때문에 도커를 이용해서 Redis, 그리고 Jenkins 소프트웨어 패키지를 도커를 통해 이용해보고자 하였습니다.

</div>
</details>
    
  
  <details>
<summary> **Redis** </summary>
<div markdown="1">


    채팅의 경우 진행되면 한명에 최소 수십개, 이후 최대 수백개의 데이터가 요청되며 실시간으로 진행 될 경우 수없이 많은 mysql에 요청과 요구가 진행 될 것입니다. 그렇게 된다면 많은 SQL문의 처리 요청으로 서버에서 동시에 진행 할 수 있는 처리 한계치를 넘어서게 되고 운영업체에서는 DB서버에 많은 메모리 증가, CPU증설을 해야 하는 상황이 발생할 수 있습니다.
    
    MySQL 서버의 성능 문제로 서버가 중단되면 서버교체 비용과 서비스가 중단되는 지점이 생기고 임계치를 넘어갈 때마다 매번 작업을 진행해야 할 것 입니다. 하지만 캐시에 저장하는 인메모리 구조의 레디스를 사용한다면 실시간 채팅에서 mySQL로의 지속적인 SQL문 생성을 막을 수 있을 것이라고 생각했습니다.
    
    Redis는 다음과 같은 특징을 지닙니다.
    
    - In-memory 데이터 저장소: 디스크에 데이터를 저장하는 다른 데이터베이스들(PostgreSQL, MongoDB 등)과 달리 데이터를 메모리에 위치시킴으로서 속도면에서 우위를 점함.
    - 유연한 데이터 구조: Key-Value 구조이외에도 다양한 데이터 구조를 지원함.
    - 단순성 및 사용 편의성
    - 복제 및 지속성
    - 높은 가용성 및 확장성(Scale-up, Scale-out)
    - 확장성: 오픈 소스인 만큼 공급업체 기술 종속적이지 않음 (Spring 지원)
    
    다음과 같은 장점들을 고려해 , 레디스를 사용하여 채팅을 개발하였습니다.

</div>
</details>
    

  <details>
<summary> **Stomp** </summary>
<div markdown="1">

    Stomp는 Simple Text Oriented Messaging Protocol의 약자로, Websocket 위에서 동작하는 텍스트 기반 메세징 프로토콜입니다.
    
    Publish-Subscribe 매커니즘을 제공하기 때문에 Broket을 통해서 다른 사용자에게 메세지를 보내거나 서버가 특정 작업을 수행하도록 메세지를
    
    보낼 수 있습니다. 또한 Http와 마찬가지로 frame을 사용해 전송하는 프로토콜입니다.
    
    각 커넥션마다 websocketHandler를 구현하여 사용하기 보다 Controller Annotation이 적용된 객체를 이용해 조직적으로 관리할 수 있습니다.
    
    예를 들어 @MessageMapping을 이용하여 Controller객체에 라우팅 시킬 수 있습니다. 또한 Stomp의 URI경로인 Destiantion을 기반으로 Spring Security를 적용해 메세지를 보호할 수 있습니다. 즉 메세징 프로토콜과 메세징 형식을 개발할 필요가 없어집니다.
    
    ps) Frame은 명령과 추가적인 헤더, 바디로 구성이 됩니다. 이는 첫번째 라인에는 텍스트(Command)이고 이후 key:value형태로 헤더정보를 포함합니다.

</div>
</details>


